## 2. Add Two Numbers (Сложить два числа)

Вам дается два не пустых связанных списка, представляющих два неотрицательных целых числа. Цифры хранятся в обратном порядке, и каждый из их узлов содержит одну цифру. Сложите два числа и верните сумму в виде связанного списка.

Вы можете предположить, что два числа не содержат ни одного ведущего нуля, кроме самого числа 0.

#### Пример 1:

- Входные параметры: l1 = [2, 4, 3], l2 = [5, 6, 4]
- Выходные параметры: [7, 0, 8]
- Объяснение: 342 + 465 = 807

![Add two numbers](https://raw.githubusercontent.com/slemeshaev/Leetcode/main/2_Add_Two_Numbers/images/linked-list.png)

#### Пример 2:

- Входные параметры: l1 = [0], l2 = [0]
- Выходные параметры: [0]

#### Пример 3:

- Входные параметры: l1 = [9, 9, 9, 9, 9, 9, 9], l2 = [9, 9, 9, 9]
- Выходные параметры: [8, 9, 9, 9, 0, 0, 0, 1]


#### Ограничения:

- Количество узлов в каждом связанном списке находится в диапазоне [1, 100].
- 0 <= Node.val <= 9
- Гарантируется, что список представляет число, не имеющее ведущих нулей.

### Решение

#### Способ 1: Элементарная математика

#### Интуиция

Отслеживайте перенос с помощью переменной и имитируйте сумму цифр за цифрами, начиная с заголовка списка, который содержит наименее значимую цифру.

![Рисунок 1](https://raw.githubusercontent.com/slemeshaev/Leetcode/main/2_Add_Two_Numbers/images/sum-linked-lists.png)

Рисунок 1. Визуализация сложения двух чисел: 342 + 465 = 807. 

Каждый узел содержит одну цифру и цифры хранятся в обратном порядке.

#### Алгоритм

Точно так же, как вы суммируете два числа на листе бумаги, мы начинаем с суммирования наименее значимых цифр, которые являются головами `l1` и `l2`. Поскольку каждая цифра находится в диапазоне `0...9`, сумма двух цифр может быть "переполнена". 

Например, `5 + 7 = 12`. В этом случае мы устанавливаем текущую цифру на `2` и переносим `carry = 1` на следующую итерацию. `carry` должен быть либо `0`, либо `1`, потому что наибольшая возможная сумма из двух цифр (включая `carry`) составляет `9 + 9 + 1 = 19`.

Псевдокод следующий:

- Инициализируйте текущий узел для фиктивной головы возвращающегося списка.
- Инициализируйте `carry` к `0`.
- Пройдитесь по списку `l1` и `l2` пока не достигните обоих концов и `carry` равен `0`.
	- Установите `x` на значение узла `l1`. Если `l1` достиг конца `l1`, то установите `0`.
	- Установите `y` на значение узла `l2`. Если `l2` достиг конца `l2`, то установите `0`.
	- Установите `sum = x + y + carry`.
	- Обновите `carry = sum / 10`.
	- Создайте новый узел со значением цифры `(sum mod 10)` и установите его на следующий узел текущего узла, затем продвините текущий узел к следующему.
	- Продвиньте оба `l1` и `l2`.
- Верните следующий узел фиктивной головы.

Обратите внимание, что мы используем фиктивную голову для упрощения кода. Без фиктивной головы вам придется писать дополнительные условия, чтобы инициализировать значение головы.

Будьте особенно осторожны в следующих случаях:

| Тестовый случай              | Объяснение      |
|:-----------------------------|:----------------|
| l1 = [0,1] <br> l2 = [0,1,2] | Когда один список длиннее другого.|
| l1 = [] <br> l2 = [0,1]      | Когда один список равен nil, <br> что означает пустой список. |
| l1 = [9,9] <br> l2 =[1]      | Сумма может иметь дополнительный <br> перенос единицы в конце, что легко забыть.|

#### Реализация на языке Swift

```
func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {
    let dummyHead = ListNode(0)
    var currentNode = dummyHead
    var carry = 0, p = l1, q = l2
    
    while p != nil || q != nil || carry != 0 {
        let sum = (p?.value ?? 0) + (q?.value ?? 0) + carry
        carry = sum / 10
        
        let newNode = ListNode(sum % 10)
        currentNode.next = newNode
        currentNode = newNode
        
        p = p?.next
        q = q?.next
    }
    
    return dummyHead.next
}
```

#### Анализ сложности

- Временная сложность: `O(max⁡(m,n))`. Предположим, что `m` и `n` представляют длину `l1` и `l2` соответственно, алгоритм итерирует не более `max⁡(m,n)` раз.
- Пространственная сложность: `O(1)`. Длина нового списка не превышает `max⁡(m,n)+1`. Однако мы не считаем ответ частью сложности пространства.

#### Последующие действия

Что делать, если цифры в связанном списке хранятся в нереверсивном порядке? 

Например: `(3 → 4 → 2) + (4 → 6 → 5) = 8 → 0 → 7`
