## 2. Add Two Numbers (Сложить два числа)

Вам дается два непустых связанных списка, представляющих два неотрицательных целых числа. Цифры хранятся в обратном порядке, и каждый из их узлов содержит одну цифру. Сложите два числа и верните сумму в виде связанного списка.

Вы можете предположить, что два числа не содержат ни одного ведущего нуля, кроме самого числа 0.

#### Пример 1:

- Входные параметры: l1 = [2, 4, 3], l2 = [5, 6, 4]
- Выходные параметры: [7, 0, 8]
- Объяснение: 342 + 465 = 807

![Add two numbers](https://raw.githubusercontent.com/slemeshaev/Leetcode/main/2_Add_Two_Numbers/images/Linked-List.png)

#### Пример 2:

- Входные параметры: l1 = [0], l2 = [0]
- Выходные параметры: [0]

#### Пример 3:

- Входные параметры: l1 = [9, 9, 9, 9, 9, 9, 9], l2 = [9, 9, 9, 9]
- Выходные параметры: [8, 9, 9, 9, 0, 0, 0, 1]


#### Ограничения:

- Количество узлов в каждом связанном списке находится в диапазоне [1, 100].
- 0 <= Node.val <= 9
- Гарантируется, что список представляет число, не имеющее ведущих нулей.

### Решение

#### Способ 1: Элементарная математика

#### Интуиция

Отслеживайте перенос с помощью переменной и имитируйте сумму цифр за цифрами, начиная с заголовка списка, который содержит наименее значимую цифру.

![Рисунок 1](https://raw.githubusercontent.com/slemeshaev/Leetcode/main/2_Add_Two_Numbers/images/Figure1.png)

Рисунок 1. Визуализация сложения двух чисел: 342 + 465 = 807. 

Каждый узел содержит одну цифру и цифры хранятся в обратном порядке.

#### Алгоритм

Точно так же, как вы суммируете два числа на листе бумаги, мы начинаем с суммирования наименее значимых цифр, которые являются головами `l1` и `l2`. Поскольку каждая цифра находится в диапазоне `0...9`, сумма двух цифр может быть "переполнена". 

Например, `5 + 7 = 12`. В этом случае мы устанавляем текущую цифру на `2` и переносим `carry = 1` на следующую итерацию. `carry` должен быть либо `0`, либо `1`, потому что наибольшая возможная сумма из двух цифр (включая `carry`) составляет `9 + 9 + 1 = 19`.

Псевдокод следующий:

- Инициализируйте текущий узел для фиктивной головы возвращающегося списка.
- Инициализируйте `carry` к `0`.
- Пройдитесь по списку `l1` и `l2` пока не достигните обоих концов и `carry` равен `0`.
	- Установите `x` на значение узла `l1`. Если `l1` достиг конца `l1`, то установите `0`.
	- Установите `y` на значение узла `l2`. Если `l2` достиг конца `l2`, то установите `0`.
	- Установите `sum = x + y + carry`.
	- Обновите `carry = sum / 10`.
	- Создайте новый узел со значением цифры `(sum mod 10)` и установите его на следующий узел текущего узла, затем продвините текущий узел к следующему.
	- Продвиньте оба `l1` и `l2`.
- Верните следующий узел фиктивной головы.
