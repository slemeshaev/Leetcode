## 1. Two sum (Две суммы)

Задан массив целых чисел `nums` и целое число `target`. Верните индексы двух чисел так, чтобы их сумма равнялась `target`.

Вы можете предположить, что каждый вход будет иметь ровно одно решение, и вы не можете использовать один и тот же элемент дважды.

Вы можете вернуть ответ в любом порядке.

#### Пример 1:

Входные параметры: nums = [2, 7, 11, 15], target = 9  
Выходные параметры: [0, 1]  
Объяснение: Потому что nums[0] + nums[1] == 9, мы возвращаем  [0, 1].

#### Пример 2:

Входные параметры: nums = [3, 2, 4], target = 6  
Выходные параметры: [1, 2]

#### Пример 3:

Входные параметры: nums = [3, 3], target = 6  
Выходные параметры: [0, 1]

#### Ограничения: 

- 2 <= nums.length <= 10<sup>4</sup>
- -10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>
- -10<sup>9</sup> <= target <= 10<sup>9</sup>
- Существует только один действительный ответ.

**Продолжение:** Можете ли вы придумать алгоритм, временная сложность которого меньше O(n<sup>2</sup>)?

#### Подсказка 1

Действительно наивным способом было бы искать все возможные пары чисел, но это было бы слишком медленно. Опять же, лучше попробовать наивные решения для полноты. Именно из этих наивных решений можно прийти к оптимизациям.

#### Подсказка 2

Итак, если мы зафиксируем одно из чисел, скажем `x`, нам придется просканировать весь массив, чтобы найти следующее число `y`, которое удовлетворяет условию `value - x`, где value - входной параметр. Можем ли мы изменить наш массив таким образом, чтобы поиск стал быстрее?

#### Подсказка 3

Вторая мысль заключается в том, можем ли мы, не изменяя массив, использовать дополнительное пространство для ускорения поиска. Например, можно ли использовать хэш-карту?

### Решение

#### Способ 1: Простой перебор

#### Алгоритм

Метод простого перебора очень простой. Нужно пройтись циклом по каждому элементу `x` и найти, если есть значение равное `target - x`.

#### Реализация на Swift

```
func twoSum(nums: [Int], target: Int) -> [Int] {
    var resultNums: [Int] = []
    
    for i in 0..<nums.count - 1 {
        for j in i + 1..<nums.count {
            if (nums[i] + nums[j] == target) {
                resultNums.append(i)
                resultNums.append(j)
                
                return resultNums
            }
        }
    }
    
    return resultNums
}
```

#### Анализ сложности

Временная сложность: O(n<sup>2</sup>).

Для каждого элемента мы пытаемся найти его дополнение, перебирая остаток массива, который занимает `O(n)`. Поэтому временная сложность равняется O(n<sup>2</sup>)


Ëмкостная сложность: O(1).

Требуемое пространство не зависит от размера входного массива, поэтому используется только постоянное пространство.

#### Способ 2: Двухпроходная хэш-таблица

#### Интуиция

Для улучшения временной сложности нашей программы необходимо найти более эффективный способ проверки наличия дополнения в массиве. Если дополнение существует, нам нужно получить его индекс.

Какой же способ лучше всего использовать для сохранения отображения каждого элемента массива на его индекс? Хэш-таблица.

Мы можем сократить время поиска с `O(n)` до `O(1)`, жертвуя при этом пространством в пользу скорости. Хэш-таблица прекрасно подходит для этой цели, так как она поддерживает быстрый поиск практически за константное время. Я говорю "практически", потому что если происходит коллизия, поиск может затянуться до `O(n)`. Однако, поиск в хэш-таблице должен иметь амортизированное время `O(1)`, при условии, что хэш-функция была выбрана тщательно.

#### Алгоритм

Простая реализация включает две итерации:
- В первой итерации мы добавляем значение каждого элемента в качестве ключа и его индекс в качестве значения в хэш-таблицу.
- Во второй итерации, мы проверяем, существует ли дополнение `(target − nums[i])` каждого элемента в хэш-таблице. Если такое дополнение существует, мы возвращаем индекс текущего элемента и индекс его дополнения. Остерегайтесь того, чтобы дополнение не было самим числом `nums[i]`!

#### Реализация на Swift

```
func twoPassHashTable(nums: [Int], target: Int) -> [Int] {
    var dictionary: [Int : Int] = [:]
    var resultNums: [Int] = []
    
    for (index, value) in nums.enumerated() {
        dictionary[value] = index
    }
    
    for (index, value) in nums.enumerated() {
        let complement = target - value
        
        if let complementIndex = dictionary[complement], complementIndex != index {
            resultNums.append(index)
            resultNums.append(complementIndex)
            
            return resultNums
        }
    }
    
    return resultNums
}

```