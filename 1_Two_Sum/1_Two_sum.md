## 1. Two sum (Две суммы)

Задан массив целых чисел `nums` и целое число `target`. Верните индексы двух чисел так, чтобы их сумма равнялась `target`.

Вы можете предположить, что каждый вход будет иметь ровно одно решение, и вы не можете использовать один и тот же элемент дважды.

Вы можете вернуть ответ в любом порядке.

#### Пример 1:

Входные параметры: nums = [2, 7, 11, 15], target = 9  
Выходные параметры: [0, 1]  
Объяснение: Потому что nums[0] + nums[1] == 9, мы возвращаем  [0, 1].

#### Пример 2:

Входные параметры: nums = [3, 2, 4], target = 6  
Выходные параметры: [1, 2]

#### Пример 3:

Входные параметры: nums = [3, 3], target = 6  
Выходные параметры: [0, 1]

#### Ограничения: 

- 2 <= nums.length <= 10<sup>4</sup>
- -10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>
- -10<sup>9</sup> <= target <= 10<sup>9</sup>
- Существует только один действительный ответ.

**Продолжение:** Можете ли вы придумать алгоритм, временная сложность которого меньше O(n<sup>2</sup>)?

#### Подсказка 1

Действительно наивным способом было бы искать все возможные пары чисел, но это было бы слишком медленно. Опять же, лучше попробовать наивные решения для полноты. Именно из этих наивных решений можно прийти к оптимизациям.

#### Подсказка 2

Итак, если мы зафиксируем одно из чисел, скажем `x`, нам придется просканировать весь массив, чтобы найти следующее число `y`, которое удовлетворяет условию `value - x`, где value - входной параметр. Можем ли мы изменить наш массив таким образом, чтобы поиск стал быстрее?

#### Подсказка 3

Вторая мысль заключается в том, можем ли мы, не изменяя массив, использовать дополнительное пространство для ускорения поиска. Например, можно ли использовать хэш-карту?

### Решение

#### Способ 1: Простой перебор

#### Алгоритм

Метод простого перебора очень простой. Нужно пройтись циклом по каждому элементу `x` и найти, если есть значение равное `target - x`.

#### Реализация на Swift

```
func twoSum(nums: [Int], target: Int) -> [Int] {
    var resultNums: [Int] = []
    
    for i in 0..<nums.count - 1 {
        for j in i + 1..<nums.count {
            if (nums[i] + nums[j] == target) {
                resultNums.append(i)
                resultNums.append(j)
                
                return resultNums
            }
        }
    }
    
    return resultNums
}
```

#### Анализ сложности

Временная сложность: O(n<sup>2</sup>).

Для каждого элемента мы пытаемся найти его дополнение, перебирая остаток массива, который занимает `O(n)`. Поэтому временная сложность равняется O(n<sup>2</sup>)


Ëмкостная сложность: O(1).

Требуемое пространство не зависит от размера входного массива, поэтому используется только постоянное пространство.