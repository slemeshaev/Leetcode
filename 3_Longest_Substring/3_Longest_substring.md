## 3. Longest substring without repeating characters (Самая длинная подстрока без повторяющихся символов)

Задана строка `s`. Найдите длину самой большой строки без повторяющихся символов.

#### Пример 1:

- Входные параметры: s = "abcabcbb"
- Выходные параметры: 3
- Объяснение: Ответом является "abc" с длиной 3.

#### Пример 2:

- Входные параметры: s = "bbbbb"
- Выходные параметры: 1
- Объяснение: Ответом является "b" с длиной 1.

#### Пример 3:

- Входные параметры: s = "pwwkew"
- Выходные параметры: 3
- Объяснение: Ответом является "wke" с длиной 3.

Обратите внимание, что ответ должен быть подстрокой. "pwke" - это подпоследовательность, а не подстрока.

#### Ограничения:

- 0 <= s.length <= 5 * 10<sup>4</sup>
- s содержит английские буквы, цифры, символы и пробелы.

### Решение

#### Алгоритм

Для начала нам нужно создать несколько переменных: `maxLength` - для хранения максимальной длины подстроки, `uniqueSymbols` - для хранения уникальных символов в текущей подстроке, `start` и `end` - для указания начала и конца текущей подстроки соответственно.

Далее выполняем итерацию по строке `s`, увеличивая переменную `end` от начала строки до ее конца. На каждом шаге проверяется, содержит ли множество уникальных символов `uniqueSymbols` текущий символ `s[end]`. Если нет, символ добавляется в множество `uniqueSymbols`, переменная `end` увеличивается на 1, и вычисляется текущая длина подстроки с помощью функции `distance(from:to:)`. Затем результат сравнивается с текущим максимальным значением `maxLength` и сохраняется наибольшее из двух.

Если символ уже содержится в множестве `uniqueSymbols`, происходит удаление символа, находящегося в переменной `start` из множества `uniqueSymbols`, и переменная `start` увеличивается на 1.

Алгоритм завершает свою работу после прохода по всей строке `s` и возвращает найденную максимальную длину подстроки без повторяющихся символов.

В конце возвращаем длину самой длинной подстроки без повторяющихся символов в заданной строке.

#### Полезные методы

- `startIndex` - позиция первого символа в непустой строке.
- `endIndex` - возвращает индекс, следующий за последним допустимым индексом коллекции. Это означает, что endIndex указывает на элемент, расположенный за пределами коллекции, и не является допустимым индексом для доступа к элементам.
- `contains()` используется для проверки наличия определенного элемента в коллекции. Он принимает параметр в виде значения, которое нужно найти в коллекции, и возвращает булево значение (true или false) в зависимости от того, содержит ли коллекция указанный элемент.
- `insert()` вставляет заданный элемент в множество, если он еще не присутствует.
- `index(before:x)` возвращает индекс, находящийся перед символом `x`.
- `index(after:x)` возвращает индекс, находящийся после символа `x`.
- `max(x,y)` возвращает наибольшее значение из двух переданных параметров.
- `distance(from:x, to:y)` возвращает расстояние между двумя индексами `x` и `y`.
- `remove()` удаляет заданный элемент из множества.

#### Реализация на Swift

```
func lengthOfLongestSubstring(_ s: String) -> Int {
    var maxLength = 0
    var uniqueSymbols = Set<Character>()
    var start = s.startIndex, end = s.startIndex
    
    while end < s.endIndex {
        if !uniqueSymbols.contains(s[end]) {
            uniqueSymbols.insert(s[end])
            end = s.index(after: end)
            maxLength = max(maxLength, s.distance(from: start, to: end))
        } else {
            uniqueSymbols.remove(s[start])
            start = s.index(after: start)
        }
    }
    
    return maxLength
}
```

#### Анализ сложности

- **Временная сложность** cоставляет `O(n)`, где `n` - длина входной строки `s`. В худшем случае алгоритм будет иметь линейную сложность, так как проходит по каждому символу в строке один раз и выполняет константное количество операций на каждой итерации. При обработке каждого символа алгоритм либо добавляет его в множество уникальных символов и увеличивает переменную `end`, либо удаляет символ из множества и увеличивает переменную `start`. Обе эти операции имеют сложность `O(1)`, что делает общую временную сложность алгоритма линейной по отношению к длине входной строки.

- **Ëмкостная сложность** составляет `O(min(n, m))`, где `n` - длина входной строки `s`, а `m` - размер алфавита символов, из которых состоит строка `s`. В данном случае алгоритм использует дополнительную память для хранения множества уникальных символов `uniqueSymbols`, которое может содержать символы из алфавита строки `s`.